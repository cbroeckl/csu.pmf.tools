#' pmfanova
#'
#' perform principle compponent analysis on ramclustR object dataset, export plots
#' @details This function performs standard or mixed model anova using a ramclusR object as input 
#' 
#' @param ramclustObj ramclustR object to perform ANOVA on
#' @param anova.name character; optionally assign a name to the anova. valuable if you wish to perform more than one ANOVA on a sample set. If NULL, name will be autogenerated from the anova.call and subset information. 
#' @param which.data character; which dataset (SpecAbund or SpecAbundAve) to perform PCA on. 
#' @param subset character vector; must be even length.  If you wish to perform ANOVA only when your factor called 'treatment' is a 'trt' sample and when 'time' is '3', then you would use is i.e. c("treatment", "trt", "time", "3"). vector length must always be even, and with 'factor' followed by 'level'. 
#' @param anova.call charachter;  the model you wish to run.  i.e. "Trt * Time" or "Trt * Time + (1|Block)" 
#' @param posthoc character; if you wish to perform post hoc testing, define the posthoc test to use.  i.e. if anova.call is "Trt * Time" you can use "Trt|Time" to specific 'treatment within time' comparisons.
#' @param effectsplots logical; if TRUE, plot effect plots in pdf format.  If plotting fails, can set to 'FALSE' to get tabular results only.
#' @param delim character; what is the character delimiting factors in the sample names.  generally '-'
#' @param plots logical; if plotting is any issue set this to FALSE. 
#' @param pcut numeric; what is the pvalue cutoff for determining significance?  Used only for plotting. 
#' @param p.adj character; what p.adjust method should be used.  generally 'fdr' or 'bh' (equivalent). see ?p.adjust
#' @param which.quan; chracter vector.  which factors should be interpreted as quantitative?  i.e. c("time", "dose")
#' @return returns a ramclustR object.  new R object in $pca slot. Optionally, new R object in $AuerGervini slot if npc = "auto".
#' @concept RAMClustR
#' @author Corey Broeckling

#' @export 


pmfanova<-function(ramclustObj=RC,
                   anova.name = NULL,
                   which.data="SpecAbund",
                   subset = c(""),
                   anova.call=NULL,
                   posthoc=NULL,
                   effectsplots=TRUE,
                   delim="-",
                   plots=TRUE,
                   pcut=0.05,
                   p.adj="BH",
                   which.quan=NULL
) {
  require(effects)
  require(lme4)
  require(lmerTest)
  require(lsmeans)
  require(pbkrtest)
  
  if(!dir.exists("stats")) {
    dir.create('stats')
  }
  if(!dir.exists("stats/anova")) {
    dir.create('stats/anova')
  }
  
  d <- csu.pmf.tools::getData(ramclustObj, which.data)
  
  ## remove samples that have NA values in any factor from anova.call
  keep <- rep(TRUE, nrow(d[[1]]))
  
  for(i in 1:ncol(d[[1]])) {
    if(!grepl(names(d[[1]])[i], anova.call)) next
    na.vals <- which(is.na(d[[1]][,i]))
    na.vals <- c(na.vals, which(d[[1]][,i] == "NA"))
    if(length(na.vals)==0) next
    keep[na.vals] <- FALSE
  }
  if(any(!keep)) {
    cat("excluding", length(which(!keep)), "samples with 'NA' values from ANOVA.", '\n')
    d[[1]] <- d[[1]][keep,]
    d[[2]] <- d[[2]][keep,]
    d[[3]] <- d[[3]][keep,]
  }
  
  if(!is.null(which.quan)) {
    for(i in 1:length(which.quan)) {
      d[[1]][,i] <- as.numeric(d[[1]][,i])
    }
  }
  
  for(i in 1:ncol(d[[1]])) {
    d[[1]][,i] <- as.factor(d[[1]][,i])
  }
  
  if(is.null(ramclustObj$history)) {
    ramclustObj$history <- ""
  }
  
  
  if(!grepl("Analysis of variance was performed in R", ramclustObj$history)) {
    ramclustObj$history <- paste(
      ramclustObj$history, '\n', '\n',
      "Analysis of variance was performed in R.", 
      paste0("The ",  which.data, " dataset was used as input."), 
      if(!is.null(which.quan)) {paste0("The factor(s) [", paste(which.quan, collapse = " "), "] are treated as numeric." )}
    )
  }
  
  
  if(is.null(anova.name)) {
    if(length(subset)>1) {
      anova.name <- paste(paste(subset, collapse = "."), paste(strsplit(gsub("[^[:alnum:] ]", "", anova.call), " +")[[1]], collapse = "."), sep = "_")
    } else {
      anova.name <- paste(strsplit(gsub("[^[:alnum:] ]", "", anova.call), " +")[[1]], collapse = ".")
    }
  }
  
  out.dir <- paste0("stats/anova/", anova.name)
  while(dir.exists(out.dir)) {
    out.dir <- paste0(out.dir, "_", format(Sys.time(), "%H%M%S"))
  }
  
  dir.create(out.dir)
  anova.name <- basename(out.dir)
  
  ramclustObj$history <- paste(
    ramclustObj$history,
    paste0("For the analysis of variance titled '", anova.name, "',"),
    "the", which.data, "dataset was used as described below."
  )
  
  if(length(subset) > 1) {
    if(length(subset)/2 != round(length(subset)/2)) stop("'subset' length must be even", '\n')
    subset <- matrix(subset, nrow = 2)
    keep <- 1:nrow(d[[1]])
    for(i in 1:ncol(subset)) {
      if(!any(names(d[[1]]) == subset[1,i])) {
        stop(paste("factor", subset[1,i], "was not found", '\n'))
      }
      f <- as.character(d[[1]][,subset[1,i]])
      k <- which(f == subset[2,i])
      if(length(k) == 0) {
        stop(paste("level", subset[2,], "in factor", subset[1,i], "was not found", '\n'))
      }
      keep <- sort(intersect(keep, k))
    }
    d[[1]] <- d[[1]][keep,]
    d[[2]] <- d[[2]][keep,]
    d[[3]] <- d[[3]][keep,]
    ramclustObj$history <- paste(
      ramclustObj$history,
      paste0("The dataset was subsetted to include only samples for which [") 
    )
    for(i in 1:ncol(subset)) {
      ramclustObj$history <- paste(ramclustObj$history, paste0(subset[1,i], "=", subset[2,i]))
    }
    ramclustObj$history <- paste0(ramclustObj$history, ".")
  }
  
  dat<-d[[3]]
  cmpd <- colnames(d[[2]])
  
  if(grepl("1|", anova.call, fixed = TRUE)) {use<-2} else {use<-1}
  
  
  if(use == 1) {
    cat("using fixed linear model analysis", '\n')
    test <- lm(as.formula(paste(ramclustObj$cmpd[1], "~", anova.call)), data = dat)
    res<-lapply(1:length(cmpd), FUN = function(x){
      lm(as.formula(paste(ramclustObj$cmpd[x], "~", anova.call)), data = dat)
    })
    pnames<-attr(attr(res[[1]]$model, which="terms"), which="term.labels")
    mp<-data.frame(lapply(1:length(res), FUN=function(x) {anova(res[[x]])$"Pr(>F)"[1:length(pnames)]}))
    dimnames(mp)[[1]] <- pnames
    dimnames(mp)[[2]] <- cmpd
    
    ramclustObj$history <- paste(
      ramclustObj$history,
      "Fixed-factor linear model ANOVA was performed using the lm function.", 
      paste0("The model used was '", anova.call, ".'")
    )
    
  } 
  
  if(use == 2) {
    cat("using mixed linear model analysis",'\n')
    test <- lmerTest::lmer(as.formula(paste(cmpd[1], "~", anova.call)), data = dat)
    res<-lapply(1:length(cmpd), FUN = function(x){
      lmerTest::lmer(as.formula(paste(cmpd[x], "~", anova.call)), data = dat)
    })
    pnames<-dimnames((anova(test, ddf="Kenward-Roger"))[1])[[1]]
    mp<-data.frame(lapply(1:length(res), FUN=function(x) {anova(res[[x]], ddf="Kenward-Roger")$"Pr(>F)"}))
    if(length(pnames) == dim(mp)[[2]]) {mp <- as.data.frame(t(mp))}
    dimnames(mp)[[1]] <- pnames
    dimnames(mp)[[2]] <- cmpd
    ramclustObj$history <- paste(
      ramclustObj$history,
      "Mixed model ANOVA was performed using the lmer and lmerTest functions.", 
      paste0("The model used was '", anova.call, ".'"),
      "P-values were assigned using the 'anova' function with ddf set to 'Kenward-Roger.'"
    )
    
  }
  cat(out.dir, '\n')
  
  sink(file = paste0(out.dir, "/model_details.txt"))
  print(sessionInfo())
  cat('\n', '\n')
  for(i in 1:length(res)) {
    cat('\n', '\n')
    cat(cmpd[i])
    cat('\n', '\n')
    print(res[[i]])
    cat('\n')
    print(anova(res[[i]]))
    cat('\n', '\n', '\n')
  }
  sink()
  save(res, file = paste0(out.dir, "/models_r_objects.Rdata"))
  
  ##optionally return posthoc results using tukey HSD
  if(!is.null(posthoc)) {
    for(j in 1:length(posthoc)) {
      test <- lsmeans(res[[1]], as.formula(paste("pairwise ~", posthoc[j])), data=dat, method = "tukey")
      phres<-lapply(1:length(res), 
                    FUN=function (x) {
                      lsmeans(res[[x]], as.formula(paste("pairwise ~", posthoc[j])), data=dat, method = "tukey")
                    })
      tmp <- summary(test$contrasts)
      pnames <- paste(strsplit(posthoc[j], "|", fixed = TRUE)[[1]], collapse = " within ")
      pnames <- paste0(pnames, ": ", tmp$contrast) 
      if(!is.data.frame(tmp)) pnames <- paste(pnames, tmp[[2]])
      pdata <- data.frame(lapply(1:length(phres), FUN = function(x) {summary(phres[[x]]$contrasts)$p.value }))
      dimnames(pdata)[[1]] <- pnames
      dimnames(pdata)[[2]] <- dimnames(mp)[[2]]
      mp<-rbind(mp, pdata)
    }
    ramclustObj$history <- paste(
      ramclustObj$history,
      paste0("Post-hoc testing was performed for [", paste(posthoc, sep = " "), "] using the 'Tukey' method in the lsmeans package.")
    )
    
  }
  
  ## apply pvalue correction
  for(i in 1:nrow(mp)) {
    mp[i,] <- p.adjust(mp[i,], method=p.adj, n = (dim(mp)[1]*dim(mp)[2]))
    ramclustObj$history <- paste(
      ramclustObj$history,
      "P-value correction was performed using the p.adjust function with method set to", 
      paste0(p.adj, ".")
    )
  }
  
  if(effectsplots) {
    
    testplot<-try(
      allEffects(res[[1]]), silent = TRUE
    )
    # cat(class(testplot), '\n')
    if(class(testplot) != 'try-error') {
      pdf(file=paste0(out.dir, "/effectsplots.pdf"), width=16, height=8)
      
      for(i in 1:length(res)) {
        # cat(i, '\n')
        plot(allEffects(res[[i]]), main=ramclustObj$ann[i], ylab="effect size (signal intensity)")
      }
      dev.off()
    } else { 
      cat("effects plots failed:", '\n')
    }
    ramclustObj$history <- paste(
      ramclustObj$history,
      "Effects plots are generated using the allEffects function."
    )
  }
  # out.dir
  ramclustObj[[paste0("anova.pval_", anova.name)]] <- mp
  
  if(!is.null(ramclustObj$clrt)){
    
    pldata <- t(rbind("rt" = round(ramclustObj$clrt, digits = 1), mp))
    for(j in ncol(pldata):2) {
      if(all(is.na(pldata[,j]))) {
        pldata <- pldata[,-j]
      }
    }
    plcols <- pldata
    plcols[,2:ncol(plcols)] <- "gray"
    plcols[which(pldata <= 0.05, arr.ind = TRUE)] <- rgb(red=0, green=80, blue=0, max=255)
    if(ncol(pldata) < 2) {break} 
    
    # pwr <- 1
    # cexs <- ramclustObj$msint^(1/pwr)/median(ramclustObj$msint^(1/pwr))
    # while(max(cexs) > 6) {
    #   pwr <- pwr + 1
    #   cexs <- ramclustObj$msint^(1/pwr)/median(ramclustObj$msint^(1/pwr))
    # }
    # cex.rg <- seq(min(cexs), max(cexs), length.out = 5)
    # int.rg <- seq(from = min(ramclustObj$msint), to = max(ramclustObj$msint), by = )
    
    ints <- log10(ramclustObj$msint)^2
    cexs <- 3*(ints)/max(ints)
    ## backcalculation: range(10^(range(ints)^0.5))
    cex.rg <- seq(min(cexs), max(cexs), length.out = 5)
    int.rg <- seq(from = min(ints), to = max(ints), length.out = 5)
    int.rg <- 10^(int.rg^0.5)
    
    pdf(file=paste0(out.dir, "/anova_summary.pdf"), width=10, height=8)
    for(i in 2:ncol(pldata)) {
      par(xpd=FALSE)
      plot(pldata[,1], -log10(pldata[,i]), 
           xlab="retention time (seconds)",
           ylab="-log(pvalue)", ylim = c(0, -log10(min(0.04, min(pldata[,i])))),
           cex.axis=1, cex.lab=1, main=paste("ANOVA p-values:", dimnames(pldata)[[2]][i]), bty='L',
           pch=21, cex=cexs, bg=plcols[,i], 
           sub = "circle size reflects median feature intensity", cex.sub = 0.5)
      abline(h=-log10(pcut), col=gray(0.4), lty=2)
      par(xpd = TRUE)
      legend(legend=formatC(round(int.rg)), x.intersp = 2, y.intersp = max(cex.rg/1.5),
             x= "topright", inset=c(-0.05,0),
             pt.cex=cex.rg, bty="n", pch=21, bg=rgb(red=0, green=80, blue=0, max=255) )
      par(xpd=FALSE)
    }
    dev.off()
    
    if(!is.null(ramclustObj$clrt) & !is.null(ramclustObj$annconf)) {
      write.csv(file=paste0(out.dir, "/anova_pvalues.csv"), 
                data.frame("cmpd"=ramclustObj$cmpd, "annotation"=ramclustObj$ann, 
                           "annconf"=ramclustObj$annconf, "rt"=ramclustObj$clrt, t(mp), check.names=FALSE), row.names=FALSE)} else {
                             write.csv(file="stats/anova/anova_pvalues.csv", mp, row.names=TRUE)
                           }
  }
  return(ramclustObj)
}

