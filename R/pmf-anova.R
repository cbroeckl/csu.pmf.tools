#' pmfanova
#'
#' perform principle compponent analysis on ramclustR object dataset, export plots
#' @details This function performs standard or mixed model anova using a ramclusR object as input 
#' 
#' @param ramclustObj ramclustR object to perform ANOVA on
#' @param anova.name character; optionally assign a name to the anova. valuable if you wish to perform more than one ANOVA on a sample set. If NULL, name will be autogenerated from the anova.call and subset information. 
#' @param which.data character; which dataset (SpecAbund or SpecAbundAve) to perform PCA on. 
#' @param subset character or integer vector; if character, must be even length.  If you wish to perform ANOVA only when your factor called 'treatment' is a 'trt' sample and when 'time' is '3', then you would use  i.e. c("treatment", "trt", "time", "3"). vector length must always be even, and with 'factor' followed by 'level'.  If an integer vector is provided, only row numbers matching those integers are retained. 
#' @param anova.call character;  the model you wish to run.  i.e. "Trt * Time" or "Trt * Time + (1|Block)" 
#' @param posthoc character; if you wish to perform post hoc testing, define the posthoc test to use.  i.e. if anova.call is "Trt * Time" you can use "Trt|Time" to specific 'treatment within time' comparisons.
#' @param effectsplots logical; if TRUE, plot effect plots in pdf format.  If plotting fails, can set to 'FALSE' to get tabular results only.
#' @param label.by  how should metabolites columns be labelled? one of 'ann' or 'cmpd', typically. 
#' @param delim character; what is the character delimiting factors in the sample names.  generally '-'
#' @param plots logical; if plotting is any issue set this to FALSE. 
#' @param pcut numeric; what is the pvalue cutoff for determining significance?  Used only for plotting. 
#' @param p.adj character; what p.adjust method should be used.  generally 'fdr' or 'bh' (equivalent). see ?p.adjust
#' @param which.quan; chracter vector.  which factors should be interpreted as quantitative?  i.e. c("time", "dose")
#' @param filter logical, TRUE by default. when $cmpd.use slot is present (from rc.cmpd.filter.cv function), only cmpds that passed cv filtering are used. If you wish to change that behavior, rerun the rc.cmpd.filter.cv function with a really high CV threshold. 
#' @return returns a ramclustR object.  new R object in $pca slot. Optionally, new R object in $AuerGervini slot if npc = "auto".
#' @concept RAMClustR
#' @author Corey Broeckling

#' @export 


pmfanova<-function(ramclustObj=RC,
                   anova.name = NULL,
                   which.data="SpecAbund",
                   label.by = "cmpd", 
                   subset = c(""),
                   anova.call=NULL,
                   posthoc=NULL,
                   effectsplots=TRUE,
                   delim="-",
                   plots=TRUE,
                   pcut=0.05,
                   p.adj="BH",
                   which.quan=NULL,
                   filter = TRUE
) {
  require(effects)
  require(lme4)
  require(lmerTest)
  require(lsmeans)
  require(pbkrtest)
  
  if(!dir.exists("stats")) {
    dir.create('stats')
  }
  if(!dir.exists("stats/anova")) {
    dir.create('stats/anova')
  }
  
  d <- getData(
    ramclustObj = ramclustObj, 
    which.data = which.data, 
    filter = filter,
    cmpdlabel = label.by
  )
  
  if(filter){
    if(!is.null(ramclustObj$cmpd.use)) {
      if(length(ramclustObj$cmpd.use == ncol(d[[2]]))) {
        cmpd.use <- which(ramclustObj$cmpd.use)
      } else {
        cmpd.use <- 1:ncol(d[[2]])
      }
    } else {
      cmpd.use <- 1:ncol(d[[2]])
    }
  } else {
    cmpd.use <- 1:ncol(d[[2]])
  }
  
  
  ## remove samples that have NA values in any factor from anova.call
  keep <- rep(TRUE, nrow(d[[1]]))
  
  for(i in 1:ncol(d[[1]])) {
    if(!grepl(names(d[[1]])[i], anova.call)) next
    na.vals <- which(is.na(d[[1]][,i]))
    na.vals <- c(na.vals, which(d[[1]][,i] == "NA"))
    if(length(na.vals)==0) next
    keep[na.vals] <- FALSE
  }
  if(any(!keep)) {
    cat("excluding", length(which(!keep)), "samples with 'NA' values from ANOVA.", '\n')
    d[[1]] <- d[[1]][keep,]
    d[[2]] <- d[[2]][keep,]
    d[[3]] <- d[[3]][keep,]
  }
  
  if(!is.null(which.quan)) {
    for(i in 1:length(which.quan)) {
      d[[1]][,i] <- as.numeric(d[[1]][,i])
    }
  }
  
  for(i in 1:ncol(d[[1]])) {
    d[[1]][,i] <- as.factor(d[[1]][,i])
  }
  
  
  
  ramclustObj$history$anova <- paste(
    "Analysis of variance was performed in R.", 
    paste0("The ",  which.data, " dataset was used as input."), 
    if(!is.null(which.quan)) {paste0("The factor(s) [", paste(which.quan, collapse = " "), "] are treated as numeric." )}
  )
  
  
  if(is.null(anova.name)) {
    if(length(subset)>1) {
      anova.name <- paste(paste(subset, collapse = "."), paste(strsplit(gsub("[^[:alnum:] ]", "", anova.call), " +")[[1]], collapse = "."), sep = "_")
    } else {
      anova.name <- paste(strsplit(gsub("[^[:alnum:] ]", "", anova.call), " +")[[1]], collapse = ".")
    }
  }
  
  out.dir <- paste0("stats/anova/", anova.name)
  while(dir.exists(out.dir)) {
    out.dir <- paste0(out.dir, "_", format(Sys.time(), "%H%M%S"))
  }
  
  dir.create(out.dir)
  anova.name <- basename(out.dir)
  
  ramclustObj$history$anova[[2]] <- paste(
    paste0("For the analysis of variance titled '", anova.name, "',"),
    "the", which.data, "dataset was used as described below."
  )
  
  if(length(subset) > 1) {
    if(is.integer(subset))  {
      d[[1]] <- d[[1]][subset,]
      d[[2]] <- d[[2]][subset,]
      d[[3]] <- d[[3]][subset,]
    } else {
      if(length(subset)/2 != round(length(subset)/2)) stop("'subset' length must be even", '\n')
      subset <- matrix(subset, nrow = 2)
      keep <- 1:nrow(d[[1]])
      for(i in 1:ncol(subset)) {
        if(!any(names(d[[1]]) == subset[1,i])) {
          stop(paste("factor", subset[1,i], "was not found", '\n'))
        }
        f <- as.character(d[[1]][,subset[1,i]])
        k <- which(f == subset[2,i])
        if(length(k) == 0) {
          stop(paste("level", subset[2,], "in factor", subset[1,i], "was not found", '\n'))
        }
        keep <- sort(intersect(keep, k))
      }
      d[[1]] <- d[[1]][keep,]
      d[[2]] <- d[[2]][keep,]
      d[[3]] <- d[[3]][keep,]
      # ramclustObj$history$anova3 <- paste(
      #   paste0("The dataset was subsetted to include only samples for which [") 
      # )
      # for(i in 1:ncol(subset)) {
      #   ramclustObj$history <- paste(ramclustObj$history, paste0(subset[1,i], "=", subset[2,i]))
      # }
      # ramclustObj$history <- paste0(ramclustObj$history, ".")
    }
    
  }
  
  dat<-d[[3]]
  cmpd <- colnames(d[[2]])
  
  if(grepl("1|", anova.call, fixed = TRUE)) {use<-2} else {use<-1}
  
  
  if(use == 1) {
    cat("using fixed linear model analysis", '\n')
    test <- lm(as.formula(paste(cmpd[1], "~", anova.call)), data = dat)
    res<-lapply(1:length(cmpd), FUN = function(x){
      lm(as.formula(paste(cmpd[x], "~", anova.call)), data = dat)
    })
    pnames<-attr(attr(res[[1]]$model, which="terms"), which="term.labels")
    mp<-data.frame(lapply(1:length(res), FUN=function(x) {anova(res[[x]])$"Pr(>F)"[1:length(pnames)]}))
    dimnames(mp)[[1]] <- pnames
    dimnames(mp)[[2]] <- cmpd
    
    ramclustObj$history$anova4 <- paste(
      "Fixed-factor linear model ANOVA was performed using the lm function.", 
      paste0("The model used was '", anova.call, ".'")
    )
    
  } 
  
  if(use == 2) {
    cat("using mixed linear model analysis",'\n')
    test <- lmerTest::lmer(as.formula(paste(cmpd[1], "~", anova.call)), data = dat)
    res<-lapply(1:length(cmpd), FUN = function(x){
      lmerTest::lmer(as.formula(paste(cmpd[x], "~", anova.call)), data = dat)
    })
    pnames<-dimnames((anova(test, ddf="Kenward-Roger"))[1])[[1]]
    mp<-data.frame(lapply(1:length(res), FUN=function(x) {anova(res[[x]], ddf="Kenward-Roger")$"Pr(>F)"}))
    if(length(pnames) == dim(mp)[[2]]) {mp <- as.data.frame(t(mp))}
    dimnames(mp)[[1]] <- pnames
    dimnames(mp)[[2]] <- cmpd
    ramclustObj$history$anova5 <- paste(
      "Mixed model ANOVA was performed using the lmer and lmerTest functions.", 
      paste0("The model used was '", anova.call, ".'"),
      "P-values were assigned using the 'anova' function with ddf set to 'Kenward-Roger.'"
    )
    
  }
  cat(out.dir, '\n')
  
  sink(file = paste0(out.dir, "/model_details.txt"))
  print(sessionInfo())
  cat('\n', '\n')
  for(i in 1:length(res)) {
    cat('\n', '\n')
    cat(cmpd[i])
    cat('\n', '\n')
    print(res[[i]])
    cat('\n')
    print(anova(res[[i]]))
    cat('\n', '\n', '\n')
  }
  sink()
  save(res, file = paste0(out.dir, "/models_r_objects.Rdata"))
  
  ##optionally return posthoc results using tukey HSD
  if(!is.null(posthoc)) {
    for(j in 1:length(posthoc)) {
      test <- lsmeans(res[[1]], as.formula(paste("pairwise ~", posthoc[j])), data=dat, method = "tukey")
      phres<-lapply(1:length(res), 
                    FUN=function (x) {
                      lsmeans(res[[x]], as.formula(paste("pairwise ~", posthoc[j])), data=dat, method = "tukey")
                    })
      tmp <- summary(test$contrasts)
      pnames <- paste(strsplit(posthoc[j], "|", fixed = TRUE)[[1]], collapse = " within ")
      pnames <- paste0(pnames, ": ", tmp$contrast) 
      if(!is.data.frame(tmp)) pnames <- paste(pnames, tmp[[2]])
      pdata <- data.frame(lapply(1:length(phres), FUN = function(x) {summary(phres[[x]]$contrasts)$p.value }))
      dimnames(pdata)[[1]] <- pnames
      dimnames(pdata)[[2]] <- dimnames(mp)[[2]]
      mp<-rbind(mp, pdata)
    }
    ramclustObj$history$anova6 <- paste(
      paste0("Post-hoc testing was performed for [", paste(posthoc, sep = " "), "] using the 'Tukey' method in the lsmeans package.")
    )
    
  }
  
  ## apply pvalue correction
  for(i in 1:nrow(mp)) {
    mp[i,] <- p.adjust(mp[i,], method=p.adj, n = (dim(mp)[1]*dim(mp)[2]))
    ramclustObj$history$anova7 <- paste(
      "P-value correction was performed using the p.adjust function with method set to", 
      paste0(p.adj, ".")
    )
  }
  
  if(effectsplots) {
    
    testplot<-try(
      allEffects(res[[1]]), silent = TRUE
    )
    # cat(class(testplot), '\n')
    if(class(testplot) != 'try-error') {
      pdf(file=paste0(out.dir, "/effectsplots.pdf"), width=16, height=8)
      
      for(i in 1:length(res)) {
        # cat(i, '\n')
        plot(allEffects(res[[i]]), main=ramclustObj[[label.by]][i], ylab="effect size (signal intensity)")
      }
      dev.off()
    } else { 
      cat("effects plots failed:", '\n')
    }
    ramclustObj$history$anova8 <- paste(
      "Effects plots are generated using the allEffects function."
    )
  }
  # out.dir
  ramclustObj[[paste0("anova.pval_", anova.name)]] <- mp
  
  if(!is.null(ramclustObj$clrt)){
    
    pldata <- t(rbind("rt" = round(ramclustObj$clrt, digits = 1), mp))
    for(j in ncol(pldata):2) {
      if(all(is.na(pldata[,j]))) {
        pldata <- pldata[,-j]
      }
    }
    plcols <- pldata
    plcols[,2:ncol(plcols)] <- "gray"
    plcols[which(pldata <= 0.05, arr.ind = TRUE)] <- rgb(red=0, green=80, blue=0, max=255)
    if(ncol(pldata) < 2) {break} 
    
    # pwr <- 1
    # cexs <- ramclustObj$msint^(1/pwr)/median(ramclustObj$msint^(1/pwr))
    # while(max(cexs) > 6) {
    #   pwr <- pwr + 1
    #   cexs <- ramclustObj$msint^(1/pwr)/median(ramclustObj$msint^(1/pwr))
    # }
    # cex.rg <- seq(min(cexs), max(cexs), length.out = 5)
    # int.rg <- seq(from = min(ramclustObj$msint), to = max(ramclustObj$msint), by = )
    
    ints <- log10(ramclustObj$msint)^2
    cexs <- 3*(ints)/max(ints)
    ## backcalculation: range(10^(range(ints)^0.5))
    cex.rg <- seq(min(cexs), max(cexs), length.out = 5)
    int.rg <- seq(from = min(ints), to = max(ints), length.out = 5)
    int.rg <- 10^(int.rg^0.5)
    
    pdf(file=paste0(out.dir, "/anova_summary.pdf"), width=10, height=8)
    for(i in 2:ncol(pldata)) {
      par(xpd=FALSE)
      plot(pldata[,1], -log10(pldata[,i]), 
           xlab="retention time (seconds)",
           ylab="-log(pvalue)", ylim = c(0, -log10(min(0.04, min(pldata[,i])))),
           cex.axis=1, cex.lab=1, main=paste("ANOVA p-values:", dimnames(pldata)[[2]][i]), bty='L',
           pch=21, cex=cexs, bg=plcols[,i], 
           sub = "circle size reflects median feature intensity", cex.sub = 0.5)
      abline(h=-log10(pcut), col=gray(0.4), lty=2)
      par(xpd = TRUE)
      legend(legend=formatC(round(int.rg)), x.intersp = 2, y.intersp = max(cex.rg/1.5),
             x= "topright", inset=c(-0.05,0),
             pt.cex=cex.rg, bty="n", pch=21, bg=rgb(red=0, green=80, blue=0, max=255) )
      par(xpd=FALSE)
    }
    dev.off()
    
    if(!is.null(ramclustObj$clrt) & !is.null(ramclustObj$annconf)) {
      write.csv(file=paste0(out.dir, "/anova_pvalues.csv"), 
                data.frame("cmpd"=ramclustObj$cmpd[cmpd.use], "annotation"=ramclustObj$ann[cmpd.use], 
                           "annconf"=ramclustObj$annconf[cmpd.use], "rt"=ramclustObj$clrt[cmpd.use],
                           t(mp), check.names=FALSE), row.names=FALSE)} else {
                             write.csv(file="stats/anova/anova_pvalues.csv", mp, row.names=TRUE)
                           }
  }
  return(ramclustObj)
}

